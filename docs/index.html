<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Robot Tank — Color Object Follower (Web Demo)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #111827; }
    .mono { font-family: 'Roboto Mono', monospace; }
    .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; inset: 0; background:#4b5563; transition:.4s; border-radius:34px;}
    .slider:before { content:""; position:absolute; height:26px; width:26px; left:4px; bottom:4px; background:#fff; transition:.4s; border-radius:50%; }
    input:checked + .slider { background:#4f46e5; }
    input:checked + .slider:before { transform: translateX(26px); }
    input[type="color"] { appearance:none; width:48px; height:32px; border:none; border-radius:8px; cursor:pointer; background:transparent; }
    input[type="color"]::-webkit-color-swatch { border-radius:8px; border:2px solid #6b7280; }
    input[type="color"]::-moz-color-swatch { border-radius:8px; border:2px solid #6b7280; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .spinner { display:inline-block; width:1.25rem; height:1.25rem; border-radius:50%; border:3px solid rgba(255,255,255,0.3); border-top-color:#fff; animation:spin 1s linear infinite; }
  </style>
</head>
<body class="bg-gray-900 text-gray-200 grid place-items-center min-h-screen p-4">

  <main class="flex flex-col items-center w-full max-w-full">
    <div class="w-full max-w-3xl text-center">
      <h1 class="text-3xl md:text-4xl font-bold text-white">Color Object Follower Demo</h1>
      <p class="text-gray-400 mt-2">A web-based demo of a computer vision node using OpenCV.js.</p>
      <p class="text-gray-400 mt-1">Click <b>Start</b>, allow camera access, and show an object of the selected color.</p>
      <p class="text-gray-500 text-sm mt-1">(A green dot marks the center of the detected object)</p>
    </div>
    <div class="relative z-20 mt-6 flex items-center space-x-4">
      <button id="startBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:scale-100">
        Start
      </button>
      <button id="stopBtn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:scale-100" disabled>
        Stop
      </button>
    </div>
    <!-- Status -->
    <div id="status" class="mt-4 text-gray-400 h-12 flex items-center justify-center"></div>
    <!-- Video + overlay -->
    <div class="relative z-10 w-full max-w-3xl aspect-video bg-black rounded-xl shadow-2xl overflow-hidden mt-4">
      <video id="cam" class="w-full h-full object-cover" playsinline muted autoplay></video>
      <canvas id="overlay" class="absolute top-0 left-0 w-full h-full pointer-events-none"></canvas>
    </div>
    <!-- Controls -->
    <div class="relative z-20 flex items-center space-x-6 mt-4">
      <div class="flex items-center space-x-3">
        <label for="maskToggle" class="text-gray-300">Show Mask:</label>
        <label class="switch">
          <input type="checkbox" id="maskToggle">
          <span class="slider"></span>
        </label>
      </div>
      <div class="flex items-center space-x-3">
        <label for="colorPicker" class="text-gray-300">Track Color:</label>
        <input type="color" id="colorPicker" value="#FF0000">
      </div>
    </div>
    <div class="mono bg-gray-800 text-gray-300 p-4 rounded-lg mt-6 text-lg shadow-inner">
      vx: <span id="vx" class="font-bold text-green-400">0.00</span>,
      wz: <span id="wz" class="font-bold text-yellow-400">0.00</span>
    </div>
    <canvas id="hiddenCanvas" style="display:none;"></canvas>
  </main>

  <!-- Load OpenCV.js first; call `onOpenCvReady()` when loaded -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
  <script>
    function onOpenCvReady() {
      // Wait for runtime if needed
      if (typeof cv === 'undefined') {
        // In rare cases, script isn't ready at onload, so fallback:
        setTimeout(onOpenCvReady, 100);
        return;
      }
      if (cv.getBuildInformation) {
        document.addEventListener('DOMContentLoaded', mainInit);
      } else if (cv['onRuntimeInitialized']) {
        // Already set, but keep for completeness
        cv['onRuntimeInitialized'] = () => document.addEventListener('DOMContentLoaded', mainInit);
      } else {
        // Set custom runtime initializer if not present
        cv['onRuntimeInitialized'] = () => document.dispatchEvent(
          new Event('DOMContentLoaded')
        );
        document.addEventListener('DOMContentLoaded', mainInit);
      }
    }

    // ===================== MAIN APP LOGIC =====================

    function mainInit() {
      // ---------- DOM ----------
      const $ = id => document.getElementById(id);
      const startBtn     = $('startBtn');
      const stopBtn      = $('stopBtn');
      const videoEl      = $('cam');
      const overlayEl    = $('overlay');
      const statusEl     = $('status');
      const vxEl         = $('vx');
      const wzEl         = $('wz');
      const maskToggle   = $('maskToggle');
      const hiddenCanvas = $('hiddenCanvas');
      const colorPicker  = $('colorPicker');

      // ---------- State ----------
      let loopActive = false;
      let stream = null;
      let cvObjects = {};
      let trackingParams = {};
      let isCvInitialized = false;

      videoEl.setAttribute('playsinline','');
      videoEl.muted = true;

      // ---------- Color helpers ----------
      function hexToRgb(hex) {
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : null;
      }
      function rgbToHsv(r,g,b) {
        r/=255; g/=255; b/=255;
        const max=Math.max(r,g,b), min=Math.min(r,g,b);
        const d=max-min;
        let h=0, s=max===0?0:d/max, v=max;
        if (d !== 0) {
          switch (max) {
            case r: h=(g-b)/d + (g<b?6:0); break;
            case g: h=(b-r)/d + 2; break;
            default: h=(r-g)/d + 4; break;
          }
          h/=6;
        }
        return { h: Math.round(h*179), s: Math.round(s*255), v: Math.round(v*255) }; // OpenCV ranges
      }
      function setColorThresholds(hexColor) {
        const rgb = hexToRgb(hexColor);
        if (!rgb) return;
        const hsv = rgbToHsv(rgb.r, rgb.g, rgb.b);
        const hueTol = 12, minS=70, minV=70;
        let hmin = hsv.h - hueTol, hmax = hsv.h + hueTol;

        if (hmin < 0) {
          trackingParams.low1  = [0,   minS, minV, 0];
          trackingParams.high1 = [hmax,255,  255,  255];
          trackingParams.low2  = [180+hmin, minS, minV, 0];
          trackingParams.high2 = [179, 255,  255,  255];
        } else if (hmax > 179) {
          trackingParams.low1  = [hmin, minS, minV, 0];
          trackingParams.high1 = [179,  255,  255,  255];
          trackingParams.low2  = [0,    minS, minV, 0];
          trackingParams.high2 = [hmax-180,255,255,255];
        } else {
          trackingParams.low1  = [hmin, minS, minV, 0];
          trackingParams.high1 = [hmax, 255,  255,  255];
          trackingParams.low2  = [0,0,0,0];
          trackingParams.high2 = [0,0,0,0];
        }
      }

      // ---------- Cleanup ----------
      const safeDelete = x => { try { if (x && typeof x.delete === 'function') x.delete(); } catch(_){} };
      function cleanupCvObjects() {
        Object.values(cvObjects).forEach(safeDelete);
        cvObjects = {};
        trackingParams = {};
      }

      stopBtn.addEventListener('click', () => {
        loopActive = false;
        if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
        videoEl.srcObject = null;
        cleanupCvObjects();
        isCvInitialized = false;
        statusEl.textContent = 'Camera stopped.';
        startBtn.disabled = false;
        stopBtn.disabled = true;
        const ctx = overlayEl.getContext('2d');
        ctx && ctx.clearRect(0,0,overlayEl.width||0, overlayEl.height||0);
        vxEl.textContent = '0.00';
        wzEl.textContent = '0.00';
      });

      colorPicker.addEventListener('input', () => {
        if (isCvInitialized) setColorThresholds(colorPicker.value);
      });

      startBtn.addEventListener('click', async () => {
        startBtn.disabled = true;
        stopBtn.disabled = true;
        loopActive = true;
        isCvInitialized = false;

        try {
          // 1) Load OpenCV (it's already loaded when we're here)
          statusEl.innerHTML = `
            <div class="flex items-center">
              <div class="spinner"></div>
              <span class="ml-2 font-medium">Vision library loaded…</span>
            </div>`;
          await Promise.resolve(); // just let UI update

          // 2) Camera
          statusEl.textContent = 'Requesting camera access…';
          stream = await navigator.mediaDevices.getUserMedia({
            video: { width:{ideal:640}, height:{ideal:480}, facingMode:'user' },
            audio: false
          });
          videoEl.srcObject = stream;

          await new Promise(res => { videoEl.onloadedmetadata = res; });
          await videoEl.play();
          stopBtn.disabled = false;
          statusEl.textContent = 'Starting analysis…';

          // 3) Main loop
          const hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });
          let frameCounter = 0; // Reset counter on start

          const onFrame = () => {
            if (!loopActive) return;

            // --- OPTIMIZATION: Process every other frame to reduce CPU load ---
            frameCounter++;
            if (frameCounter % 2 !== 0) {
                requestAnimationFrame(onFrame);
                return;
            }

            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            let largestContour = null;

            try {
              const w = videoEl.videoWidth, h = videoEl.videoHeight;
              if (!w || !h) { requestAnimationFrame(onFrame); return; }

              if (!isCvInitialized) {
                overlayEl.width = w; overlayEl.height = h;
                hiddenCanvas.width = w; hiddenCanvas.height = h;

                cvObjects.bgr     = new cv.Mat(h, w, cv.CV_8UC3);
                cvObjects.hsv     = new cv.Mat(h, w, cv.CV_8UC3);
                cvObjects.mask1   = new cv.Mat();
                cvObjects.mask2   = new cv.Mat();
                cvObjects.mask    = new cv.Mat();
                cvObjects.opened  = new cv.Mat();
                cvObjects.closed  = new cv.Mat();
                cvObjects.kernel  = cv.Mat.ones(3, 3, cv.CV_8U);

                setColorThresholds(colorPicker.value);
                isCvInitialized = true;
                statusEl.textContent = 'Running analysis…';
              }

              hiddenCtx.drawImage(videoEl, 0, 0, w, h);
              let rgba = cv.imread(hiddenCanvas);
              cv.cvtColor(rgba, cvObjects.bgr, cv.COLOR_RGBA2BGR);
              safeDelete(rgba);

              cv.cvtColor(cvObjects.bgr, cvObjects.hsv, cv.COLOR_BGR2HSV);
              const low1  = new cv.Scalar(...trackingParams.low1);
              const high1 = new cv.Scalar(...trackingParams.high1);
              const low2  = new cv.Scalar(...trackingParams.low2);
              const high2 = new cv.Scalar(...trackingParams.high2);

              cv.inRange(cvObjects.hsv, low1, high1, cvObjects.mask1);
              cv.inRange(cvObjects.hsv, low2, high2, cvObjects.mask2);
              safeDelete(low1); safeDelete(high1); safeDelete(low2); safeDelete(high2);

              cv.bitwise_or(cvObjects.mask1, cvObjects.mask2, cvObjects.mask);
              cv.morphologyEx(cvObjects.mask,   cvObjects.opened, cv.MORPH_OPEN,  cvObjects.kernel);
              cv.morphologyEx(cvObjects.opened, cvObjects.closed, cv.MORPH_CLOSE, cvObjects.kernel);

              let vx = 0, wz = 0;
              const ctx = overlayEl.getContext('2d');
              ctx.clearRect(0, 0, w, h);

              if (maskToggle.checked) {
                cv.imshow('overlay', cvObjects.closed);
              } else {
                cv.findContours(cvObjects.closed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                if (contours.size() > 0) {
                  let largestArea = 0;
                  for (let i = 0; i < contours.size(); i++) {
                    const tempContour = contours.get(i);
                    const area = cv.contourArea(tempContour);
                    if (area > largestArea) {
                      largestArea = area;
                      safeDelete(largestContour); // Delete previous
                      largestContour = tempContour;
                    } else {
                      safeDelete(tempContour);
                    }
                  }
                  if (largestContour) {
                    const m = cv.moments(largestContour);
                    if (m.m00 > 0) {
                      const cx = m.m10 / m.m00;
                      const cy = m.m01 / m.m00;

                      let err = (cx - (w/2)) / (w/2);
                      if (Math.abs(err) < 0.05) err = 0.0;
                      wz = Math.max(-1, Math.min(1, -1.2 * err));

                      const frac = largestArea / (w * h);
                      const ef = 0.020 - frac;
                      vx = Math.abs(ef) < 0.004 ? 0.0 : Math.max(-1, Math.min(1, ef / 0.020));

                      ctx.beginPath();
                      ctx.arc(cx, cy, 8, 0, 2*Math.PI);
                      ctx.fillStyle = 'rgba(0, 255, 0, 0.85)';
                      ctx.fill();
                      ctx.lineWidth = 2;
                      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                      ctx.stroke();
                    }
                  }
                }
              }

              vxEl.textContent = vx.toFixed(2);
              wzEl.textContent = wz.toFixed(2);
            } catch (err) {
              console.error('Error in onFrame:', err);
              if (loopActive) stopBtn.click();
            } finally {
              safeDelete(contours);
              safeDelete(hierarchy);
              safeDelete(largestContour);
            }

            requestAnimationFrame(onFrame);
          };

          requestAnimationFrame(onFrame);
        } catch (err) {
          console.error('Error during startup:', err);
          statusEl.textContent = 'Error: ' + err.message;
          startBtn.disabled = false;
          stopBtn.disabled = true;
        }
      });
    }
  </script>
</body>
</html>
