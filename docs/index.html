<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Robot Tank â€” Color Object Follower (Web Demo)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #111827; }
    .mono { font-family: 'Roboto Mono', monospace; }
    .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; inset: 0; background:#4b5563; transition:.4s; border-radius:34px;}
    .slider:before { content:""; position:absolute; height:26px; width:26px; left:4px; bottom:4px; background:#fff; transition:.4s; border-radius:50%; }
    input:checked + .slider { background:#4f46e5; }
    input:checked + .slider:before { transform: translateX(26px); }
    input[type="color"] { appearance:none; width:48px; height:32px; border:none; border-radius:8px; cursor:pointer; background:transparent; }
    input[type="color"]::-webkit-color-swatch { border-radius:8px; border:2px solid #6b7280; }
    input[type="color"]::-moz-color-swatch { border-radius:8px; border:2px solid #6b7280; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .spinner { display:inline-block; width:1.25rem; height:1.25rem; border-radius:50%; border:3px solid rgba(255,255,255,0.3); border-top-color:#fff; animation:spin 1s linear infinite; }
  </style>
</head>
<body class="bg-gray-900 text-gray-200 grid place-items-center min-h-screen p-4">

  <main class="flex flex-col items-center w-full max-w-full">
    <div class="w-full max-w-3xl text-center">
      <h1 class="text-3xl md:text-4xl font-bold text-white">Color Object Follower Demo</h1>
      <p class="text-gray-400 mt-2">A web-based demo of a computer vision node using OpenCV.js.</p>
      <p class="text-gray-400 mt-1">Click <b>Start</b>, allow camera access, and show an object of the selected color.</p>
      <p class="text-gray-500 text-sm mt-1">(A green dot marks the center of the detected object)</p>
    </div>
    <div class="relative z-20 mt-6 flex items-center space-x-4">
      <button id="startBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:scale-100">
        Start
      </button>
      <button id="stopBtn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:scale-100" disabled>
        Stop
      </button>
    </div>
    <!-- Status -->
    <div id="status" class="mt-4 text-gray-400 h-12 flex items-center justify-center"></div>
    <!-- Video + overlay -->
    <div class="relative z-10 w-full max-w-3xl aspect-video bg-black rounded-xl shadow-2xl overflow-hidden mt-4">
      <video id="cam" class="w-full h-full object-cover" playsinline muted autoplay></video>
      <canvas id="overlay" class="absolute top-0 left-0 w-full h-full pointer-events-none"></canvas>
    </div>
    <!-- Controls -->
    <div class="relative z-20 flex items-center space-x-6 mt-4">
      <div class="flex items-center space-x-3">
        <label for="maskToggle" class="text-gray-300">Show Mask:</label>
        <label class="switch">
          <input type="checkbox" id="maskToggle">
          <span class="slider"></span>
        </label>
      </div>
      <div class="flex items-center space-x-3">
        <label for="colorPicker" class="text-gray-300">Track Color:</label>
        <input type="color" id="colorPicker" value="#FF0000">
      </div>
    </div>
    <div class="mono bg-gray-800 text-gray-300 p-4 rounded-lg mt-6 text-lg shadow-inner">
      vx: <span id="vx" class="font-bold text-green-400">0.00</span>,
      wz: <span id="wz" class="font-bold text-yellow-400">0.00</span>
    </div>
    <canvas id="hiddenCanvas" style="display:none;"></canvas>
  </main>

  <!-- Load OpenCV.js -->
  <script>
    let cvReady = false;
    let domReady = false;

    function checkReady() {
      if (cvReady && domReady) {
        mainInit();
      }
    }

    // OpenCV loading with better error handling
    function loadOpenCV() {
      const script = document.createElement('script');
      script.async = true;
      script.src = 'https://docs.opencv.org/4.x/opencv.js';
      
      script.onload = () => {
        if (typeof cv === 'undefined') {
          console.log('Waiting for OpenCV to initialize...');
          setTimeout(() => {
            if (typeof cv !== 'undefined') {
              if (cv.getBuildInformation) {
                cvReady = true;
                checkReady();
              } else {
                cv['onRuntimeInitialized'] = () => {
                  cvReady = true;
                  checkReady();
                };
              }
            }
          }, 100);
        } else {
          if (cv.getBuildInformation) {
            cvReady = true;
            checkReady();
          } else {
            cv['onRuntimeInitialized'] = () => {
              cvReady = true;
              checkReady();
            };
          }
        }
      };
      
      script.onerror = () => {
        console.error('Failed to load OpenCV.js');
        document.getElementById('status').textContent = 'Error: Failed to load OpenCV.js';
      };
      
      document.head.appendChild(script);
    }

    document.addEventListener('DOMContentLoaded', () => {
      domReady = true;
      checkReady();
    });

    // Start loading OpenCV immediately
    loadOpenCV();

    // ===================== MAIN APP LOGIC =====================

    function mainInit() {
      console.log('Initializing app with OpenCV version:', cv.getBuildInformation());
      
      // ---------- DOM ----------
      const $ = id => document.getElementById(id);
      const startBtn     = $('startBtn');
      const stopBtn      = $('stopBtn');
      const videoEl      = $('cam');
      const overlayEl    = $('overlay');
      const statusEl     = $('status');
      const vxEl         = $('vx');
      const wzEl         = $('wz');
      const maskToggle   = $('maskToggle');
      const hiddenCanvas = $('hiddenCanvas');
      const colorPicker  = $('colorPicker');

      // ---------- State ----------
      let loopActive = false;
      let stream = null;
      let cvObjects = {};
      let trackingParams = {};
      let isCvInitialized = false;

      videoEl.setAttribute('playsinline','');
      videoEl.muted = true;

      // ---------- Color helpers ----------
      function hexToRgb(hex) {
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : null;
      }
      
      function rgbToHsv(r,g,b) {
        r/=255; g/=255; b/=255;
        const max=Math.max(r,g,b), min=Math.min(r,g,b);
        const d=max-min;
        let h=0, s=max===0?0:d/max, v=max;
        if (d !== 0) {
          switch (max) {
            case r: h=(g-b)/d + (g<b?6:0); break;
            case g: h=(b-r)/d + 2; break;
            default: h=(r-g)/d + 4; break;
          }
          h/=6;
        }
        return { h: Math.round(h*179), s: Math.round(s*255), v: Math.round(v*255) }; // OpenCV ranges
      }
      
      function setColorThresholds(hexColor) {
        const rgb = hexToRgb(hexColor);
        if (!rgb) return;
        const hsv = rgbToHsv(rgb.r, rgb.g, rgb.b);
        const hueTol = 15, minS=50, minV=50;
        let hmin = hsv.h - hueTol, hmax = hsv.h + hueTol;

        if (hmin < 0) {
          trackingParams.low1  = [0,   minS, minV, 0];
          trackingParams.high1 = [hmax,255,  255,  255];
          trackingParams.low2  = [180+hmin, minS, minV, 0];
          trackingParams.high2 = [179, 255,  255,  255];
          trackingParams.useSecondRange = true;
        } else if (hmax > 179) {
          trackingParams.low1  = [hmin, minS, minV, 0];
          trackingParams.high1 = [179,  255,  255,  255];
          trackingParams.low2  = [0,    minS, minV, 0];
          trackingParams.high2 = [hmax-180,255,255,255];
          trackingParams.useSecondRange = true;
        } else {
          trackingParams.low1  = [hmin, minS, minV, 0];
          trackingParams.high1 = [hmax, 255,  255,  255];
          trackingParams.useSecondRange = false;
        }
      }

      // ---------- Cleanup ----------
      const safeDelete = x => { 
        try { 
          if (x && typeof x.delete === 'function') {
            x.delete(); 
          }
        } catch(e) {
          console.warn('Error deleting OpenCV object:', e);
        } 
      };
      
      function cleanupCvObjects() {
        Object.values(cvObjects).forEach(safeDelete);
        cvObjects = {};
        trackingParams = {};
      }

      stopBtn.addEventListener('click', () => {
        loopActive = false;
        if (stream) { 
          stream.getTracks().forEach(t => t.stop()); 
          stream = null; 
        }
        videoEl.srcObject = null;
        cleanupCvObjects();
        isCvInitialized = false;
        statusEl.textContent = 'Camera stopped.';
        startBtn.disabled = false;
        stopBtn.disabled = true;
        const ctx = overlayEl.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, overlayEl.width || 0, overlayEl.height || 0);
        }
        vxEl.textContent = '0.00';
        wzEl.textContent = '0.00';
      });

      colorPicker.addEventListener('input', () => {
        if (isCvInitialized) setColorThresholds(colorPicker.value);
      });

      startBtn.addEventListener('click', async () => {
        startBtn.disabled = true;
        stopBtn.disabled = true;
        loopActive = true;
        isCvInitialized = false;

        try {
          statusEl.innerHTML = `
            <div class="flex items-center">
              <div class="spinner"></div>
              <span class="ml-2 font-medium">Starting camera...</span>
            </div>`;

          // Request camera
          stream = await navigator.mediaDevices.getUserMedia({
            video: { 
              width: { ideal: 640 }, 
              height: { ideal: 480 }, 
              facingMode: 'user' 
            },
            audio: false
          });
          
          videoEl.srcObject = stream;

          // Wait for video to be ready
          await new Promise((resolve, reject) => {
            videoEl.onloadedmetadata = resolve;
            videoEl.onerror = reject;
            setTimeout(() => reject(new Error('Video loading timeout')), 10000);
          });

          await videoEl.play();
          stopBtn.disabled = false;
          statusEl.textContent = 'Initializing computer vision...';

          // Give video a moment to start streaming
          await new Promise(resolve => setTimeout(resolve, 500));

          // Main processing loop
          const hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });
          let frameCounter = 0;

          const processFrame = () => {
            if (!loopActive) return;

            frameCounter++;
            // Process every 3rd frame for better performance
            if (frameCounter % 3 !== 0) {
              requestAnimationFrame(processFrame);
              return;
            }

            try {
              const w = videoEl.videoWidth;
              const h = videoEl.videoHeight;
              
              if (!w || !h) {
                requestAnimationFrame(processFrame);
                return;
              }

              // Initialize OpenCV objects on first frame
              if (!isCvInitialized) {
                overlayEl.width = w;
                overlayEl.height = h;
                hiddenCanvas.width = w;
                hiddenCanvas.height = h;

                // Create OpenCV matrices
                cvObjects.frame = new cv.Mat(h, w, cv.CV_8UC4);
                cvObjects.hsv = new cv.Mat(h, w, cv.CV_8UC3);
                cvObjects.mask1 = new cv.Mat();
                cvObjects.mask2 = new cv.Mat();
                cvObjects.mask = new cv.Mat();
                cvObjects.morphed = new cv.Mat();
                cvObjects.kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5, 5));

                setColorThresholds(colorPicker.value);
                isCvInitialized = true;
                statusEl.textContent = 'Computer vision active - show colored objects!';
              }

              // Capture frame
              hiddenCtx.drawImage(videoEl, 0, 0, w, h);
              const imageData = hiddenCtx.getImageData(0, 0, w, h);
              cvObjects.frame.data.set(imageData.data);

              // Convert to HSV
              cv.cvtColor(cvObjects.frame, cvObjects.hsv, cv.COLOR_RGBA2RGB);
              cv.cvtColor(cvObjects.hsv, cvObjects.hsv, cv.COLOR_RGB2HSV);

              // Create mask
              const low1 = new cv.Scalar(...trackingParams.low1);
              const high1 = new cv.Scalar(...trackingParams.high1);
              cv.inRange(cvObjects.hsv, low1, high1, cvObjects.mask1);

              if (trackingParams.useSecondRange) {
                const low2 = new cv.Scalar(...trackingParams.low2);
                const high2 = new cv.Scalar(...trackingParams.high2);
                cv.inRange(cvObjects.hsv, low2, high2, cvObjects.mask2);
                cv.bitwise_or(cvObjects.mask1, cvObjects.mask2, cvObjects.mask);
                low2.delete();
                high2.delete();
              } else {
                cvObjects.mask1.copyTo(cvObjects.mask);
              }

              low1.delete();
              high1.delete();

              // Morphological operations
              cv.morphologyEx(cvObjects.mask, cvObjects.morphed, cv.MORPH_OPEN, cvObjects.kernel);
              cv.morphologyEx(cvObjects.morphed, cvObjects.morphed, cv.MORPH_CLOSE, cvObjects.kernel);

              // Clear overlay
              const ctx = overlayEl.getContext('2d');
              ctx.clearRect(0, 0, w, h);

              let vx = 0, wz = 0;

              if (maskToggle.checked) {
                // Show mask
                cv.imshow('overlay', cvObjects.morphed);
              } else {
                // Find contours and track object
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                
                cv.findContours(cvObjects.morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                
                if (contours.size() > 0) {
                  let largestContour = null;
                  let largestArea = 0;
                  
                  for (let i = 0; i < contours.size(); i++) {
                    const contour = contours.get(i);
                    const area = cv.contourArea(contour);
                    
                    if (area > largestArea && area > 500) { // Minimum area threshold
                      if (largestContour) largestContour.delete();
                      largestContour = contour;
                      largestArea = area;
                    } else {
                      contour.delete();
                    }
                  }
                  
                  if (largestContour) {
                    const moments = cv.moments(largestContour);
                    if (moments.m00 > 0) {
                      const cx = moments.m10 / moments.m00;
                      const cy = moments.m01 / moments.m00;
                      
                      // Calculate control values
                      let err = (cx - (w/2)) / (w/2);
                      if (Math.abs(err) < 0.05) err = 0.0;
                      wz = Math.max(-1, Math.min(1, -1.5 * err));
                      
                      const frac = largestArea / (w * h);
                      const ef = 0.025 - frac;
                      vx = Math.abs(ef) < 0.005 ? 0.0 : Math.max(-1, Math.min(1, ef / 0.025));
                      
                      // Draw center point
                      ctx.beginPath();
                      ctx.arc(cx, cy, 10, 0, 2 * Math.PI);
                      ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                      ctx.fill();
                      ctx.lineWidth = 3;
                      ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
                      ctx.stroke();
                      
                      // Draw contour
                      ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
                      ctx.lineWidth = 2;
                      ctx.beginPath();
                      for (let i = 0; i < largestContour.rows; i++) {
                        const point = largestContour.intAt(i, 0);
                        if (i === 0) {
                          ctx.moveTo(point[0], point[1]);
                        } else {
                          ctx.lineTo(point[0], point[1]);
                        }
                      }
                      ctx.closePath();
                      ctx.stroke();
                    }
                    largestContour.delete();
                  }
                }
                
                contours.delete();
                hierarchy.delete();
              }

              vxEl.textContent = vx.toFixed(2);
              wzEl.textContent = wz.toFixed(2);

            } catch (err) {
              console.error('Error in processing loop:', err);
              statusEl.textContent = 'Error: ' + err.message;
              stopBtn.click();
            }

            requestAnimationFrame(processFrame);
          };

          requestAnimationFrame(processFrame);

        } catch (err) {
          console.error('Error during startup:', err);
          statusEl.textContent = 'Error: ' + err.message;
          startBtn.disabled = false;
          stopBtn.disabled = true;
          loopActive = false;
          if (stream) {
            stream.getTracks().forEach(t => t.stop());
            stream = null;
          }
        }
      });

      // Initial status
      statusEl.textContent = 'Ready! Click Start to begin.';
    }
  </script>
</body>
</html>
