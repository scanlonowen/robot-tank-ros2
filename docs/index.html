<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Robot Tank — Color Object Follower (Web Demo)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body { font-family: 'Inter', sans-serif; background-color: #111827; }
    .mono { font-family: 'Roboto Mono', monospace; }

    /* Toggle */
    .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; inset: 0; background:#4b5563; transition:.4s; border-radius:34px;}
    .slider:before { content:""; position:absolute; height:26px; width:26px; left:4px; bottom:4px; background:#fff; transition:.4s; border-radius:50%; }
    input:checked + .slider { background:#4f46e5; }
    input:checked + .slider:before { transform: translateX(26px); }

    /* Color input */
    input[type="color"] { appearance:none; width:48px; height:32px; border:none; border-radius:8px; cursor:pointer; background:transparent; }
    input[type="color"]::-webkit-color-swatch { border-radius:8px; border:2px solid #6b7280; }
    input[type="color"]::-moz-color-swatch { border-radius:8px; border:2px solid #6b7280; }

    /* Spinner */
    @keyframes spin { to { transform: rotate(360deg); } }
    .spinner { display:inline-block; width:1.25rem; height:1.25rem; border-radius:50%; border:3px solid rgba(255,255,255,0.3); border-top-color:#fff; animation:spin 1s linear infinite; }
  </style>
</head>
<body class="bg-gray-900 text-gray-200">
  <div class="flex flex-col items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-3xl text-center">
      <h1 class="text-3xl md:text-4xl font-bold text-white">Color Object Follower Demo</h1>
      <p class="text-gray-400 mt-2">A web-based demo of a computer vision node using OpenCV.js.</p>
      <p class="text-gray-400 mt-1">Click <b>Start</b>, allow camera access, and show an object of the selected color.</p>
      <p class="text-gray-500 text-sm mt-1">(A green dot marks the center of the detected object)</p>
    </div>

    <div class="relative z-20 mt-6 flex items-center space-x-4">
      <button id="startBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:scale-100">
        Start
      </button>
      <button id="stopBtn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:bg-gray-700 disabled:cursor-not-allowed disabled:scale-100" disabled>
        Stop
      </button>
    </div>

    <!-- Status -->
    <div id="status" class="mt-4 text-gray-400 h-12 flex items-center justify-center"></div>

    <!-- Video + overlay -->
    <div class="relative z-10 w-full max-w-3xl aspect-video bg-black rounded-xl shadow-2xl overflow-hidden mt-4">
      <video id="cam" class="w-full h-full object-cover" playsinline muted autoplay></video>
      <canvas id="overlay" class="absolute top-0 left-0 w-full h-full pointer-events-none"></canvas>
    </div>

    <!-- Controls -->
    <div class="relative z-20 flex items-center space-x-6 mt-4">
      <div class="flex items-center space-x-3">
        <label for="maskToggle" class="text-gray-300">Show Mask:</label>
        <label class="switch">
          <input type="checkbox" id="maskToggle">
          <span class="slider"></span>
        </label>
      </div>
      <div class="flex items-center space-x-3">
        <label for="colorPicker" class="text-gray-300">Track Color:</label>
        <input type="color" id="colorPicker" value="#FF0000">
      </div>
    </div>

    <div class="mono bg-gray-800 text-gray-300 p-4 rounded-lg mt-6 text-lg shadow-inner">
      vx: <span id="vx" class="font-bold text-green-400">0.00</span>,
      wz: <span id="wz" class="font-bold text-yellow-400">0.00</span>
    </div>

    <canvas id="hiddenCanvas" style="display:none;"></canvas>
  </div>

  <script>
    // ---------- DOM ----------
    const $ = id => document.getElementById(id);
    const startBtn     = $('startBtn');
    const stopBtn      = $('stopBtn');
    const videoEl      = $('cam');
    const overlayEl    = $('overlay');
    const statusEl     = $('status');
    const vxEl         = $('vx');
    const wzEl         = $('wz');
    const maskToggle   = $('maskToggle');
    const hiddenCanvas = $('hiddenCanvas');
    const colorPicker  = $('colorPicker');

    // ---------- State ----------
    let loopActive = false;
    let stream = null;
    let cvObjects = {};
    let trackingParams = {};
    let isCvInitialized = false;

    // Ensure iOS behaves
    videoEl.setAttribute('playsinline','');
    videoEl.muted = true;

    // ---------- OpenCV Load ----------
    let cv = null;
    const cvReady = new Promise((resolve, reject) => {
      // Must exist before the script loads
      window.Module = {
        onRuntimeInitialized: () => {
          cv = window.cv;
          console.log('OpenCV runtime initialized.');
          resolve(cv);
        },
        printErr: (err) => {
          console.error('OpenCV Module Error:', err);
        }
      };
      // Optional: timeout guard
      setTimeout(() => reject(new Error('OpenCV load timeout')), 30000);
    });

    // ---------- Color helpers ----------
    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : null;
    }
    function rgbToHsv(r,g,b) {
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const d=max-min;
      let h=0, s=max===0?0:d/max, v=max;
      if (d !== 0) {
        switch (max) {
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          default: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return { h: Math.round(h*179), s: Math.round(s*255), v: Math.round(v*255) }; // OpenCV ranges
    }

    function setColorThresholds(hexColor) {
      const rgb = hexToRgb(hexColor);
      if (!rgb) return;
      const hsv = rgbToHsv(rgb.r, rgb.g, rgb.b);
      const hueTol = 12, minS=70, minV=70;
      let hmin = hsv.h - hueTol, hmax = hsv.h + hueTol;

      if (hmin < 0) {
        trackingParams.low1  = [0,   minS, minV, 0];
        trackingParams.high1 = [hmax,255,  255,  255];
        trackingParams.low2  = [180+hmin, minS, minV, 0];
        trackingParams.high2 = [179, 255,  255,  255];
      } else if (hmax > 179) {
        trackingParams.low1  = [hmin, minS, minV, 0];
        trackingParams.high1 = [179,  255,  255,  255];
        trackingParams.low2  = [0,    minS, minV, 0];
        trackingParams.high2 = [hmax-180,255,255,255];
      } else {
        trackingParams.low1  = [hmin, minS, minV, 0];
        trackingParams.high1 = [hmax, 255,  255,  255];
        // disable range 2
        trackingParams.low2  = [0,0,0,0];
        trackingParams.high2 = [0,0,0,0];
      }
    }

    // ---------- Cleanup ----------
    function safeDelete(x) { try { x && typeof x.delete === 'function' && x.delete(); } catch(_){} }
    function cleanupCvObjects() {
      Object.values(cvObjects).forEach(safeDelete);
      cvObjects = {};
      trackingParams = {};
    }

    stopBtn.onclick = () => {
      loopActive = false;
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      videoEl.srcObject = null;
      cleanupCvObjects();
      isCvInitialized = false;
      statusEl.textContent = 'Camera stopped.';
      startBtn.disabled = false;
      stopBtn.disabled = true;
      const ctx = overlayEl.getContext('2d');
      ctx && ctx.clearRect(0,0,overlayEl.width||0, overlayEl.height||0);
      vxEl.textContent = '0.00';
      wzEl.textContent = '0.00';
    };

    colorPicker.oninput = () => {
      if (isCvInitialized) setColorThresholds(colorPicker.value);
    };

    startBtn.onclick = async () => {
      startBtn.disabled = true;
      stopBtn.disabled = true;
      loopActive = true;
      isCvInitialized = false;

      try {
        // 1) Load OpenCV
        statusEl.innerHTML = `
          <div class="flex items-center">
            <div class="spinner"></div>
            <span class="ml-2 font-medium">Loading vision library…</span>
          </div>`;
        await cvReady;
        statusEl.textContent = 'Vision library loaded.';

        // 2) Camera
        statusEl.textContent = 'Requesting camera access…';
        stream = await navigator.mediaDevices.getUserMedia({
          video: { width:{ideal:640}, height:{ideal:480}, facingMode:'user' },
          audio: false
        });
        videoEl.srcObject = stream;

        // Wait for metadata then play
        await new Promise(res => { videoEl.onloadedmetadata = res; });
        await videoEl.play();
        stopBtn.disabled = false;
        statusEl.textContent = 'Starting analysis…';

        // 3) Main loop
        const hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });

        const onFrame = () => {
          if (!loopActive) return;

          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();

          try {
            const w = videoEl.videoWidth, h = videoEl.videoHeight;
            if (!w || !h) { requestAnimationFrame(onFrame); return; }

            if (!isCvInitialized) {
              overlayEl.width = w; overlayEl.height = h;
              hiddenCanvas.width = w; hiddenCanvas.height = h;

              cvObjects.bgr     = new cv.Mat(h, w, cv.CV_8UC3);
              cvObjects.hsv     = new cv.Mat(h, w, cv.CV_8UC3);
              cvObjects.mask1   = new cv.Mat();
              cvObjects.mask2   = new cv.Mat();
              cvObjects.mask    = new cv.Mat();
              cvObjects.opened  = new cv.Mat();
              cvObjects.closed  = new cv.Mat();
              cvObjects.kernel  = cv.Mat.ones(5, 5, cv.CV_8U);

              setColorThresholds(colorPicker.value);
              isCvInitialized = true;
              statusEl.textContent = 'Running analysis…';
            }

            // Read frame
            hiddenCtx.drawImage(videoEl, 0, 0, w, h);
            let rgba = cv.imread(hiddenCanvas);                 // CV_8UC4
            cv.cvtColor(rgba, cvObjects.bgr, cv.COLOR_RGBA2BGR);
            safeDelete(rgba);

            // HSV + threshold
            cv.cvtColor(cvObjects.bgr, cvObjects.hsv, cv.COLOR_BGR2HSV);
            const low1  = new cv.Scalar(...trackingParams.low1);
            const high1 = new cv.Scalar(...trackingParams.high1);
            const low2  = new cv.Scalar(...trackingParams.low2);
            const high2 = new cv.Scalar(...trackingParams.high2);

            cv.inRange(cvObjects.hsv, low1, high1, cvObjects.mask1);
            cv.inRange(cvObjects.hsv, low2, high2, cvObjects.mask2);
            safeDelete(low1); safeDelete(high1); safeDelete(low2); safeDelete(high2);

            cv.bitwise_or(cvObjects.mask1, cvObjects.mask2, cvObjects.mask);
            cv.morphologyEx(cvObjects.mask,   cvObjects.opened, cv.MORPH_OPEN,  cvObjects.kernel);
            cv.morphologyEx(cvObjects.opened, cvObjects.closed, cv.MORPH_CLOSE, cvObjects.kernel);

            let vx = 0, wz = 0;
            const ctx = overlayEl.getContext('2d');
            ctx.clearRect(0, 0, w, h);

            if (maskToggle.checked) {
              // Show mask directly to the overlay canvas
              cv.imshow('overlay', cvObjects.closed);
            } else {
              cv.findContours(cvObjects.closed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

              if (contours.size() > 0) {
                let largestArea = 0, idx = -1;
                for (let i = 0; i < contours.size(); i++) {
                  const a = cv.contourArea(contours.get(i));
                  if (a > largestArea) { largestArea = a; idx = i; }
                }
                if (idx !== -1) {
                  const c = contours.get(idx);
                  const m = cv.moments(c);
                  if (m.m00 > 0) {
                    const cx = m.m10 / m.m00;
                    const cy = m.m01 / m.m00;

                    // Heading error -> angular speed
                    let err = (cx - (w/2)) / (w/2);
                    if (Math.abs(err) < 0.05) err = 0.0;
                    wz = Math.max(-1, Math.min(1, -1.2 * err));

                    // Area -> linear speed (target ~2% of frame)
                    const frac = largestArea / (w * h);
                    const ef = 0.020 - frac;
                    vx = Math.abs(ef) < 0.004 ? 0.0 : Math.max(-1, Math.min(1, ef / 0.020));

                    // Draw target center
                    ctx.beginPath();
                    ctx.arc(cx, cy, 8, 0, 2*Math.PI);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.85)';
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.stroke();
                  }
                  // c is owned by the vector; no delete needed here
                }
              }
            }

            vxEl.textContent = vx.toFixed(2);
            wzEl.textContent = wz.toFixed(2);
          } catch (err) {
            console.error('Error in onFrame:', err);
            if (loopActive) stopBtn.onclick();
          } finally {
            safeDelete(contours);
            safeDelete(hierarchy);
          }

          requestAnimationFrame(onFrame);
        };

        requestAnimationFrame(onFrame);
      } catch (err) {
        console.error('Error during startup:', err);
        statusEl.textContent = 'Error: ' + err.message;
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    };
  </script>

  <!-- Load OpenCV AFTER we define window.Module -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</body>
</html>
